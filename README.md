
# cube_cubeprime_fast

## Overview
This program tests the **cubic cube three‑prime conjecture** that every integer cube `n³` (for `n > 2`)
can be expressed as the sum of **three distinct prime numbers**:

```
n³ = p + q + r with p, q, r prime, p ≠ q ≠ r
```

The code is tuned to finish the range **3 → 20 000** in a few seconds on a modern
quad‑core CPU. It has been successfully tested up to **n ≤ 2 642 245**, the largest value that keeps
`n³` inside the unsigned 64‑bit range.

---

## Algorithm

1. **Prime sieve** – A compact bit‑array sieve of Eratosthenes up to **100 million**
is built once at program start.
* All primes are kept in a vector for fast iteration.
* Primality checks for small numbers reuse this table directly.

2. **Deterministic Miller–Rabin** – For numbers above `10 000 000`, a 7‑base
Miller–Rabin test, proven deterministic for the 64‑bit range, is used.

3. **Search strategy**
* **Phase 0** – If `n³` is even, try the pattern `2 + p + q`.
* **Phase 1** – Double loop over distinct small primes `p` and `q`;
compute `r = n³ − p − q` and test `r` with Miller–Rabin.

4. **Parallelism** – A simple work‑stealing counter distributes consecutive `n`
values to a pool of worker threads (`thread::hardware_concurrency()`).

5. **Output** – Each worker pushes its local results into a shared vector,
which is finally sorted and saved to **results.txt**.

---

## Building

```bash
g++ -std=c++20 -O3 -march=native -pthread cube_cubeprime_fast.cpp -o cube_test
```

* `-O3 -march=native` enables full vectorisation on the host CPU.
* `-pthread` links the C++ thread library.

---

## Usage

```
$ ./cube_test
start n (3-2642245): 3
end n (3-2642245): 20000
done: 19998 lines → results.txt
```

The program asks for **inclusive** start / end values and writes every
representation (or a “NO REPRESENTATION FOUND” line) to `results.txt`.

---

## Performance notes

* The program was tested on a Lenovo IdeaPad Pro 5 16IRH8 laptop with an ~5.3_3.5 GHz Intel Core i7 (13th Gen) processor, running in High Performance Mode.
* It utilized **20 threads** at full capacity with no thermal, power, or memory throttling.

* Tested range: from 3 to 2,642,245 (≈2.6 million cube values)
* Execution time: **≈ 7.3 minutes**
* Memory usage: started at **~2–3 GB** and peaked at **4.5 GB**
* RAM: 16 GB DDR5
* On a 3.5 GHz Ryzen 5 (4 cores / 8 threads) the default range `3→20 000`
completes in **≈ 19.2s**.
* Memory footprint is **≤ 110 MiB** (dominated by the 100 Mbit sieve).

---

## Limitations & Future work


* The sieve limit is fixed at *100 million*. Extending above that will
increase memory linearly. A segmented sieve or wheel optimization would
scale better.
* **Phase 1** scans `O(π(N)²)` prime pairs; heuristics or meet‑in‑the‑middle
techniques could prune the search further.
* The Miller–Rabin tester could switch to a **strong Lucus test** for slightly
faster large‑prime rejection.

---

**Conjecture: Every integer cube n³ (n > 2) = p + q + r with distinct primes

Author: Generated by Mr. Hamza Alsenwi & ChatGPT (OpenAI o3 & 4o), (My assistant and companion, even if just an LLM)
– 29 June 2025
**License:** MIT – feel free to use and modify.